我推荐的这个`lab`，名字叫做`ucore`,这个`lab`来自清华大学的操作系统课程，首先要说明一下，这确实是非常好的一个`lab`，想入门`linux`内核的同学可以读一读这个`lab`所涉及的`ucore`的源码。

## 书籍推荐

其实只要大家认认真真做下去，收获肯定会非常的大。虽然这么说，但是，这个`lab` 对大家的基础要求稍微有一点高，你至少要懂一点汇编，懂一点`C`。代码里面很多都是汇编，`C`交替着写，我推荐几本书，给大家补一下基础，大家可以参考一下。

第一本是王爽的汇编语言，这本书适合入门，但是只涉及到了8086的一点东西。书讲的浅显易懂。
<div align="center">
 <img src="https://img3.doubanio.com/lpic/s4448052.jpg" width="301" alt="汇编语言"/>
 </div>

另外一本书是《x86汇编语言--从实模式到保护模式》，这本书算是一本进阶的书籍，同时也是80386汇编入门的书籍。这本书里大部分的知识，这个`lab`都用得到，所以强烈推荐大家阅读。
<div align="center">
 <img src="https://img3.doubanio.com/lpic/s25113825.jpg" width="301" alt="x86汇编语言--从实模式到保护模式"/>
 </div>

还有一本需要参考一下的是《程序员的自我修养--链接、装载与库》,因为这个`lab`还涉及到了`elf`格式的可执行程序.
<div align="center">
 <img src="https://img3.doubanio.com/lpic/s3724604.jpg" width="301" alt="程序员的自我修养--链接、装载与库"/>
 </div>

当然，最好的话，能附带这么一本《orange's 一个操作系统的实现》，作为参考是最好不过啦。这本书的话，汇编有点多，其实很多汇编都可以用`C`来代替。不过里面有一些点，这个`lab`也涉及到了，所以推荐读一下。
<div align="center">
 <img src="https://img3.doubanio.com/lpic/s3788445.jpg" width="301" alt="orange's 一个操作系统的实现"/>
 </div>


上面的几本书里应该涉及到了这个`lab`所需要的大部分的硬件以及汇编的知识，其余的，你可以去`google`或者`baidu`。

做这个`lab`，你可能会遇到非常多的困难，比如说，调试异常困难，代码半天读不懂，没事，这都是很正常的情况。要是觉得困难实在太大，我建议你从这个玩具内核入手 -- [hurley](https://github.com/hurley25/hurlex-doc)，这个内核非常简单，适合积累一些最基本的知识。

## 关于代码的阅读
在`linux`上面读`ucore`将近`1 M`的源文件真心费力，生活其实可以简单一点，你可以使用宇宙最强的`ide`--`visual stdio`来进行代码的阅读，像我这样：
<div align="center">
 <img src="http://img.blog.csdn.net/20160929012022445" alt="代码演示"/>
 </div>
是不是很爽，告诉你，爽翻了。特别是遇到一堆不知从哪里冒出来的宏，一堆不知名的函数的时候，`VS`可以实现十万分方便的跳转。

我推荐两个插件，一个叫做`visual assistant`，这个用来增强自动补全以及跳转操作，一个叫做`visualGDB`，是一个帮助你在`window`上面写`linux`程序的插件。自己去搜索安装吧，网上教程一大堆。我就懒得写了。

当然，你不可能用`vs`来编译代码，但是，`vs`会给你阅读代码，修改代码带来非常大的方便性。

## 收获
实在做不出也没有什么关系，因为很少有人会真正去做一个操作系统吧。但是读懂源码，我觉得还是非常有必要的，我稍微讲一下，我个人读完了这个`lab`源码之后的感受吧。

- 以前学`c`的时候,我总是很好奇，`printf`之类的函数究竟是如何实现在屏幕上打印出字符的，从来没有老师讲过这些东西，现在，我懂了，原来我们只要将字符写在内存中的某个区域，然后驱动程序会自动帮我们实现字符在屏幕上的输出。

- 为什么`cpu`可以实现进程的切换？一切都是因为中断，一旦发生中断，计算机要立马切换到中断处理程序中去，利用这个特性，操作系统设定好时钟频率，让时钟每多少毫秒触发中断，内核就可以获得控制权，从而实现进程的切换。

- 一切的进程，只是一堆数据而已，只要你保存好这段数据，`cpu`先去干点别的事情,一段时间后再恢复这些数据，进程又活了。由于`cpu`的速度太快了，所以你会一直觉得进程还活着，其实它已经切换了几十次了。

- 内存的分段，分页机制真是漂亮的抽象，逻辑上连续的页，实际在内存中可能相隔十万八千里，可是这并没有关系。因为我们已经 屏蔽了它，上层的应用是永远也感觉不到差别的。

- 所谓的程序文件，加载到内存里，操作系统要对其进行重定向处理，在每个用户进程的眼里，它自己是独一无二的，分段分页机制完美地实现了进程的隔离。

- ... ...

对于我来说，收获特别大。我懂了很多以前我自认为懂了的东西，当然至于这些东西我是不是真的懂了，我也不知道，因为人的认知总是在向前推进的嘛。

但是说实话，我对写一个内核什么的，没有多么大的兴趣，所以，我不会继续钻研地太深。所以，对于这个`lab`，我也只是玩一下的。

不过，读完这个`lab`，实验完这个`lab`,加上我以前学的编译器,硬件，汇编等一系列的东西，从硬件到软件这个层次发生的事情，我现在算是比较清楚了。

如果你要问，学这些玩意对你找工作有什么益处的话，我可以说，短时间内可能还真没有什么益处，不过这些玩意，算得上是一个编程爱好者的基本修养吧。就这样吧！

**至少在现在,写一个玩具性质的操作系统并不是一件很难的事情,关键是你不熟练,写操作系统也没有很高深的技巧,它也不需要你有很高的智慧,它的理论基础在几十年前就已经成熟了,已经有无数人写了无数的操作系统,就如同编译器一样,我相信,只要你足够熟练的话,花点时间,参照各式各样的教程,你也能够写出一个操作系统,对于社会,这可能没什么卵用,但是对于你自己,你可以从中掌握到很多底层的细节.当然,这也可能没有什么卵用.**

如果感到代码层层叠叠，数据结构花样翻新的话，可以参考一下我的注释版`lab`:[cs-ucore](https://github.com/lishuhuakai/CS/tree/master/ucore) 

学了这么久的计算机，我突然感觉学海无涯，每一个点扩展出去，都是无穷无尽的，真心有点累，不行了，我要休息一段时间了。